import java.io.File;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Queue;
import java.util.Set;
import java.util.TreeSet;

import org.neo4j.graphdb.GraphDatabaseService;
import org.neo4j.graphdb.Result;
import org.neo4j.graphdb.Transaction;
import org.neo4j.graphdb.factory.GraphDatabaseFactory;
import org.neo4j.graphdb.factory.GraphDatabaseSettings;

import com.google.common.collect.Sets;

public class PolyDelay {

	static GraphDatabaseService db = null; 
	static List<ArrayList<Integer>> overallCliques= new ArrayList<>();//stores all cliques generated by ground truth
	static List<ArrayList<Integer>> overallCliques_polyDelay= new ArrayList<>();//stores all cliques generated by poly delay
	static List<ArrayList<Integer>> overallCliques_cscliques= new ArrayList<>();//stores all cliques generated by poly delay
    
	//variables for calculating confusion matrix for poly delay and cscliques2
	static int t_p_poly=0;
	static int f_n_poly=0;
	static int f_p_poly=0;
	static int t_p_cs=0;
	static int f_n_cs=0;
	static int f_p_cs=0;
	public static void main(String[] args) {

		try {
			db = new GraphDatabaseFactory()
					.newEmbeddedDatabaseBuilder(new File("data file name"))
					.setConfig(GraphDatabaseSettings.pagecache_memory, "512M" )
					.setConfig(GraphDatabaseSettings.string_block_size, "60" )
					.setConfig(GraphDatabaseSettings.array_block_size, "300" )
					.newGraphDatabase();
		
			String label = "";
			int s = 2;//single place where value of s can be changed
			
			//iterating through all target files for labels
			for(File targetFiles: new File("target file path").listFiles()) {
				label = targetFiles.getName().trim().split("\\.")[0];
				System.out.println("Label: "+label); 


				List<String> allNodes=null;
				Set<String> neigh_node=null;
				List<String> neighbors_node=null;
				List<String>clique=null;
				int index=0;

				allNodes=new ArrayList<>();
				neigh_node=new HashSet<>();

				allNodes=getAllNodesMainGraph(db,label);
				long startTime1 = System.currentTimeMillis();
				for(int i=0;i<allNodes.size();i++)

				{	
					clique=new ArrayList<>();
					neighbors_node=new ArrayList<>();
					clique.add(String.valueOf(i));
					neigh_node=getNeighborsMaingraphHops(db,label, String.valueOf(i), s);
					neigh_node.remove(String.valueOf(i));
					Set<String> curr_nodes = new HashSet<>(neigh_node);
					ArrayList<String> list_allNodes = new ArrayList<>(neigh_node);

					for(String each:list_allNodes) 
					{
						clique.add(each);
						Collections.sort(clique);
						curr_nodes.remove(each);
						helper( db, clique,   curr_nodes, each,  label, s) ;
						clique.remove(each);
						curr_nodes.add(each);	

					}
				}
				long endTime1 = System.currentTimeMillis();
								System.out.println("Time taken for computing the ground truth for label "+label+ " was "+(endTime1-startTime1));
				
				List<ArrayList<Integer>> copy_overall=new ArrayList<>();
				long startTime = System.currentTimeMillis();
				polyDelayEnum(s, label);
				long endTime = System.currentTimeMillis();

				System.out.println("Time taken for polydelay algorithm for file"+label+" was "+(endTime - startTime));
				copy_overall.addAll(overallCliques);
				copy_overall.removeAll(overallCliques_polyDelay);
				f_n_poly=copy_overall.size();
				
				System.out.println("Results after comparing with ground truth");
				System.out.println("False Positives"+f_p_poly);
				System.out.println("True Positives"+t_p_poly);
				System.out.println("False negatives"+f_n_poly);

				ArrayList<Integer> P = allNodes(label);
				startTime = System.currentTimeMillis();
				CsCliqes2(new ArrayList<Integer>(), P, new ArrayList<Integer>(), s, label);
				endTime = System.currentTimeMillis();
				System.out.println("Time taken for cscliques2 algorithm for file"+label+" was "+(endTime - startTime));
				overallCliques.removeAll(overallCliques_polyDelay);
				f_n_cs=overallCliques.size();
				
				System.out.println("Results after comparing with ground truth");
				System.out.println("False Positives"+f_p_cs);
				System.out.println("True Positives"+t_p_cs);
				System.out.println("False negatives"+f_n_cs);


				overallCliques_polyDelay=new ArrayList<>();
				overallCliques=new ArrayList<>();

			}

		}
		catch(Exception e) 
		{
			e.printStackTrace();
		}

	}
	//funtion to get all nodes present in graph
	public static ArrayList<Integer> allNodes(String Label) {

		ArrayList<Integer> neighbours = new ArrayList<Integer>();

		String cypherQuery = "Match (n1:" + Label + ") return distinct n1.iden";

		Result res = db.execute(cypherQuery);
		Map<String, Object> data = null;
		try (Transaction tx=db.beginTx()) {
			while(res.hasNext()) {

				data = new HashMap<>();
				data = res.next(); 

				int neighbourId = Integer.parseInt(data.get("n1.iden").toString()); 
				neighbours.add(neighbourId);

				data = null;
			}
			tx.success(); 
		}

		return neighbours;
	}
	//function to check if a given clique is connected  or not. used for cscliques2
	public static boolean isRConnected(ArrayList<Integer> R, String Label, int s) {

		ArrayList<Integer> neighbours = null;
		for(int id: R) {

			neighbours = forNeighboursAtS(id, Label, s);
			neighbours.add(id);
			neighbours.retainAll(R);
			if(neighbours.size() != R.size()) {
				return false;
			}

		}

		return true;
	}
	//method to implement cscliques2 algo
	public static void CsCliqes2(ArrayList<Integer> R, ArrayList<Integer> P, ArrayList<Integer> X, int s, String Label) {

		ArrayList<Integer> n1 = forSomeNeighbours(R, Label);
		ArrayList<Integer> n2 = forSomeNeighbours(R, Label);


		n1.retainAll(P);
		n2.retainAll(X);


		boolean flag = isRConnected(R, Label, s);
		//		
		if(n1.size() == 0 && n2.size() == 0 && flag) {
			

			Collections.sort(R);
			overallCliques_cscliques.add(R);

			if(overallCliques.contains(R)) 
			{
				t_p_cs=t_p_cs+1;

			}
			else 
			{
				f_p_cs+=1;
			}
		}

		ArrayList<Integer> n3 = null;
		ArrayList<Integer> n4 = null;
		ArrayList<Integer> c = null;

		Iterator<Integer> iter = P.iterator();
		while (iter.hasNext()) {
			int id = iter.next();
			n3 = forNeighboursAtS(id, Label, s);
			n3.retainAll(P);
			n4 = forNeighboursAtS(id, Label, s);
			n4.retainAll(X);
			c = new ArrayList<Integer>(R);
			c.add(id);
			CsCliqes2(c, n3, n4, s, Label);
			iter.remove();
			X.add(id);

		}


	} 
	//get neighbors at distance s
	public static ArrayList<Integer> forNeighboursAtS(int id, String Label, int s) {

		ArrayList<Integer> neighbours = new ArrayList<Integer>();

		String cypherQuery = "Match (n1:" + Label + ") -[*1.."+ s +"]- (n2:" + Label + ") where n1.iden = \""+ id 
				+"\" return distinct n2.iden";

		Result res = db.execute(cypherQuery);
		Map<String, Object> data = null;
		try (Transaction tx=db.beginTx()) {
			while(res.hasNext()) {

				data = new HashMap<>();
				data = res.next(); 

				int neighbourId = Integer.parseInt(data.get("n2.iden").toString()); 
				neighbours.add(neighbourId);

				data = null;
			}
			tx.success();
		}

		neighbours.remove(new Integer(id));
		return neighbours;
	}

	//get immediate neighbors
	public static ArrayList<Integer> forNeighboursAt1(int id, String Label) {

		ArrayList<Integer> neighbours = new ArrayList<Integer>();

		String cypherQuery = "Match (n1:" + Label + ") -- (n2:" + Label + ") where n1.iden = \""+ id 
				+"\" return distinct n2.iden";

		Result res = db.execute(cypherQuery);
		Map<String, Object> data = null;
		try (Transaction tx=db.beginTx()) {
			while(res.hasNext()) {

				data = new HashMap<>();
				data = res.next(); 

				int neighbourId = Integer.parseInt(data.get("n2.iden").toString()); 
				neighbours.add(neighbourId);

				data = null;
			}
			tx.success();
		}

		neighbours.remove(new Integer(id));
		return neighbours;
	}
	//implement polydelay enum algo
	public static void polyDelayEnum(int s, String Label) 
	{

		Set<ArrayList<Integer>> index = new HashSet<ArrayList<Integer>>();
		Queue<ArrayList<Integer>> queue = new LinkedList<ArrayList<Integer>>();

		ArrayList<Integer> c = extendedMax(new ArrayList<Integer>(), Label, s, new ArrayList<Integer>());
		ArrayList<Integer> c1 = null;
		ArrayList<Integer> c2 = null;
		ArrayList<Integer> newC = null;
		ArrayList<Integer> subgraph = null;

		Collections.sort(c);
		queue.add(c); 
		index.add(c);

		while(!queue.isEmpty()) {

			ArrayList<Integer> clique = queue.poll();
			Collections.sort(clique);
			overallCliques_polyDelay.add(clique);
			//			System.out.println(clique);

			if(overallCliques.contains(clique)) 
			{
				t_p_poly=t_p_poly+1;

			}
			else 
			{
				f_p_poly+=1;
			}

			for(int neighbour: forSomeNeighbours(clique, Label)) {

				subgraph = new ArrayList<Integer>(clique);
				subgraph.add(neighbour);
				newC = new ArrayList<Integer>();
				newC.add(neighbour);

				c1 = extendedMax(newC, Label, s, subgraph);
				c2 = extendedMax(c1, Label, s, new ArrayList<Integer>());
				Collections.sort(c2);
				if(!index.contains(c2)) {
					queue.add(c2);
					index.add(c2);	
				}

				subgraph = null;
				newC = null;
				c1 = null;
				c2 = null;
			}
			clique = null;			
		}

	}	

	//Iterate through the clique to find common neighbors at distance of s
	public static ArrayList<Integer> forAllNeighbours(ArrayList<Integer> clique, String Label, int s) {

		ArrayList<Integer> neighbours = new ArrayList();

		ArrayList<Integer> n[] = new ArrayList[clique.size()];
		for(int i=0; i < n.length; i++) {
			n[i] = new ArrayList<Integer>();
		}

		int i = 0;
		for(int id: clique) {

			String cypherQuery = "Match (n1:" + Label + ") -[*1.."+ s +"]- (n2:" + Label + ") where n1.iden = \""+ id 
					+"\" return distinct n2.iden";

			Result res = db.execute(cypherQuery);
			Map<String, Object> data = null;
			try (Transaction tx=db.beginTx()) {
				while(res.hasNext()) {

					data = new HashMap<>();
					data = res.next(); 

					int neighbourId = Integer.parseInt(data.get("n2.iden").toString()); 
					if(!n[i].contains(neighbourId)) {
						n[i].add(neighbourId);
					}
					if(!neighbours.contains(neighbourId)) {
						neighbours.add(neighbourId);
					}
					data = null;
				}
				tx.success();
			}
			i++;
		}

		for(int j=0; j < n.length; j++) {
			neighbours.retainAll(n[j]);
		}
		neighbours.removeAll(clique);
		return neighbours;
	}
	//Iterate through the clique to find immediate neighbors 
	public static ArrayList<Integer> forSomeNeighbours(ArrayList<Integer> clique, String Label) {

		ArrayList<Integer> neighbours = new ArrayList(); 
		for(int id: clique) {

			String cypherQuery = "Match (n1:" + Label + ") -- (n2:" + Label + ") where n1.iden = \""+ id 
					+"\" return distinct n2.iden";

			Result res = db.execute(cypherQuery);
			Map<String, Object> data = null;
			try (Transaction tx=db.beginTx()) {
				while(res.hasNext()) {

					data = new HashMap<>();
					data = res.next(); 

					int neighbourId = Integer.parseInt(data.get("n2.iden").toString()); 
					if(!neighbours.contains(neighbourId)) {
						neighbours.add(neighbourId);
					}
					data = null;
				}
				tx.success();
			}
		}
		neighbours.removeAll(clique);
		return neighbours;
	}
	//method to implement the intersection of forallneighbors and forsomeneighbors .This is to get all the neighbors present in the clique.
	public static ArrayList<Integer> allNeighbours(ArrayList<Integer> clique, String Label, int s) {

		ArrayList<Integer> forAllNeighbour = forAllNeighbours(clique, Label, s); 
		ArrayList<Integer> forSomeNeighbour = forSomeNeighbours(clique, Label);  

		forSomeNeighbour.retainAll(forAllNeighbour);
		forSomeNeighbour.removeAll(clique);
		return forSomeNeighbour;
	}

	//poly delay enum calls extendedmax
	public static ArrayList<Integer> extendedMax(ArrayList<Integer> clique, String Label, int s, ArrayList<Integer> graph1) {
		int arbitraryId;
		if(clique.size() == 0) {
			arbitraryId = 0;	
			clique.add(arbitraryId);
		}
		
		ArrayList<Integer> neighbours = null;
		while(true) {
			neighbours = allNeighbours(clique, Label, s);
			if(neighbours.size() == 0)
				break;
			
			if(graph1.size() != 0) {
				int flag = 0;
				for(int n: neighbours) {
					if(graph1.contains(n)) {
						flag = 1;
					}
				}
				if(flag == 0)
					break;
			}
			
			
			for(int node: neighbours) {
				if(graph1.size() == 0) {
					if(!clique.contains(node))
						clique.add(node);
				}
				else {
					if(!(clique.contains(node)) && graph1.contains(node))
						clique.add(node);
				}
			}
		}
		
		return clique;
		
	}
	//get all nodes in the main graph
	public static List<String> getAllNodesMainGraph(GraphDatabaseService database ,String filename) 
	{
		List<String> allNodesInMainGraph=new ArrayList<>();
		String query="Match (n) where n.filename='"+ filename+"' Return n.iden" ;

		Result r=database.execute(query);
		while(r.hasNext()) {
			Map<String, Object> temp = r.next();
			allNodesInMainGraph.add(String.valueOf(temp.get("n.iden")));

		}
		return allNodesInMainGraph;

	}	
	//get neighbors at distance s
	public static Set<String> getNeighborsMaingraphHops(GraphDatabaseService database,String  filename,String v,int s) 
	{
		Set<String> neighbors=new HashSet<String>();
		String query="MATCH (g1:"+filename+"{iden:\""+ v +"\"})-[*1.."+s+"]-(g2:"+filename+")   return distinct g2.iden" ;

		Result r=database.execute(query);
		while(r.hasNext())
		{
			Map<String, Object> temp = r.next();
			neighbors.add(String.valueOf( temp.get("g2.iden")));
		}

		return neighbors;

	}
	//helper function to  to generate ground truth
	private static void helper(GraphDatabaseService database,List<String> clique,  Set<String> currnodes,String node, String filename,int s) {

		ArrayList<Integer> newList = new ArrayList<Integer>(clique.size()) ;
		for (String myInt : clique) { 
			newList.add(Integer.valueOf(myInt)); 
		}	
		ArrayList<Integer>t= new ArrayList<>();
		t.addAll(new ArrayList(new HashSet(newList)));
		Collections.sort(t);
		if(currnodes.size() == 0 && !overallCliques.contains(new ArrayList<>(t))) {

			overallCliques.add(t);
		}
		Set<String> neighs =getNeighborsMaingraphHops(database, filename, node, s);

		Set<String> common_node = new HashSet<>(Sets.intersection(currnodes, neighs));
		ArrayList<String> intersection_candidate_arrayList = new ArrayList<>(common_node);

		for(String intersect_node: intersection_candidate_arrayList)
		{

			clique.add(intersect_node);
			common_node.remove(intersect_node);
			helper( database, clique,   common_node, intersect_node,  filename, s) ;
			clique.remove(intersect_node);
			common_node.add(intersect_node);
		}
	}
	
}